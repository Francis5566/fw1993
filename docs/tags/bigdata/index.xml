
   <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
     <channel>
       <title>BigData on goatwu1993</title>
       <link>https://goatwu1993.github.io/blog/tags/bigdata/</link>
       <description>Recent content in BigData on goatwu1993</description>
       <generator>Hugo -- gohugo.io</generator>
       <copyright>Copyright &amp;copy; 2019 - goatwu1993</copyright>
       <lastBuildDate>Thu, 09 Jan 2020 19:53:34 +0800</lastBuildDate>
       
           <atom:link href="https://goatwu1993.github.io/blog/tags/bigdata/index.xml" rel="self" type="application/rss+xml" />
       
       
       <item>
         <title>Apache Kafka - Part1</title>
         <link>https://goatwu1993.github.io/blog/posts/apache-kafka-part1/</link>
         <pubDate>Thu, 09 Jan 2020 19:53:34 +0800</pubDate>
         
         <guid>https://goatwu1993.github.io/blog/posts/apache-kafka-part1/</guid>
         <description>

&lt;h2 id=&#34;what-is-kafka&#34;&gt;What is Kafka&lt;/h2&gt;

&lt;h3 id=&#34;kafka-是什麼&#34;&gt;Kafka 是什麼&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Kafka 是一個流 /訊息處理平台(stream processing platform)，作為一個單一平台，可以處理 Real-Time 的資料流&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;kafka-特點&#34;&gt;Kafka 特點&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;架構簡化

&lt;ul&gt;
&lt;li&gt;Producers 只需要傳送訊息給 topic，consumer 可以選擇任何 message system 來接收訊息。&lt;/li&gt;
&lt;li&gt;Kafka 提供 pub-sub 及 queue based messaging system&lt;/li&gt;
&lt;li&gt;Kafka 基於 commit log，使用者可以 subscribec 或 publish data 到多個系統或是 App&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;網路傳輸優化&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;效率優化過的 binary TCP-based protocol&lt;/li&gt;
&lt;li&gt;記憶體緩衝機制，訊息會先寫入一個記憶體緩衝中，然後直到多條訊息組成了一個 Batch，才會一次網路通訊把 Batch 傳送過去，可以減少網路封包的 Overhead。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I/O 優化&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kafka 可提供 2 million writes/sec&lt;/li&gt;
&lt;li&gt;Kafka 將 data 保存在硬碟上，意味著寫入會經過 RAM，所以 data 傳送到 network socket 效率很高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Zookeeper&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kafka 需要 ZooKeeper 提供同步服務&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kafka 提供 Kafka Connect 連接外部系統(用於資料輸入/輸出)&lt;/li&gt;
&lt;li&gt;Kafka 提供 Kafka Streams: 一個 java stream processing 庫，Java application that consume data from Kafka and write results back to Kafka.&lt;/li&gt;
&lt;li&gt;Also works with external stream processing systems such as Apache Spark.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;kafka-優點&#34;&gt;Kafka 優點&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分散式的 publish-subscribe 訊息系統加上可靠的 queue 讓 Kafka 能夠處理巨量的資料流&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reliability 可靠性&lt;br /&gt;
Kafka is distributed, partitioned, replicated and fault tolerance.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scalability 可擴展性&lt;br /&gt;
Kafka 可以 Zero downtime 輕鬆擴展&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Durability 耐用性&lt;br /&gt;
Kafka 使用分散式 commit log，訊息會被盡快的寫到磁碟上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Performance&lt;br /&gt;
Kafka has high throughput for both publishing and subscribing messages. It maintains stable performance even many TB of messages are stored.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;zero downtime&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;zero data loss&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;kafka-example-applications&#34;&gt;Kafka Example applications&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;managing passenger and driver matching at Uber&lt;/li&gt;
&lt;li&gt;providing real-time analytics and predictive maintenance for British Gas’ smart home,&lt;/li&gt;
&lt;li&gt;performing numerous real-time services across all of LinkedIn.&lt;/li&gt;
&lt;/ul&gt;
</description>
       </item>
       
       <item>
         <title>Apache Kafka - Part2</title>
         <link>https://goatwu1993.github.io/blog/posts/apache-kafka-2/</link>
         <pubDate>Thu, 09 Jan 2020 19:53:34 +0800</pubDate>
         
         <guid>https://goatwu1993.github.io/blog/posts/apache-kafka-2/</guid>
         <description>

&lt;h2 id=&#34;kafka-名詞&#34;&gt;Kafka 名詞&lt;/h2&gt;

&lt;p&gt;Kafka 可以被分為多個 Topics，每個 topic 可以再分為多個 partitions，partition 是一個 message queue，其中 message 按照 index/offset 排序。&lt;/p&gt;

&lt;p&gt;All the data in a Kafka cluster is the disjointed union of partitions. Incoming messages are written at the end of a partition and messages are sequentially read by consumers. Durability is provided by replicating messages to different brokers.&lt;/p&gt;

&lt;h2 id=&#34;producers&#34;&gt;Producers&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Producers are the publisher of messages&lt;/li&gt;
&lt;li&gt;Producer can publish message to one or more Kafka topics.&lt;/li&gt;
&lt;li&gt;Messages are pushed to brokers.&lt;/li&gt;
&lt;li&gt;When new broker is started, all the producer search it and automatically send a message to the new broker. Producer does not wait for ack from broker and send messages as fast as broker can handle.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;topics&#34;&gt;Topics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A stream of messages belonging to a particular category is called a topic. Data is stored in topics.&lt;/li&gt;
&lt;li&gt;每個 topic 可以再分為多個 partitions，partition 是一個 message queue，其中 message 按照 index/offset 排序。&lt;/li&gt;
&lt;li&gt;For each topic, Kafka keeps a mini-mum of one partition.&lt;/li&gt;
&lt;li&gt;Each such partition contains messages in an immutable ordered sequence. A partition is implemented as a set of segment files of equal sizes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-regular-topics&#34;&gt;1. Regular Topics&lt;/h3&gt;

&lt;p&gt;Regular topics can be configured with a retention time or a space bound. If there are records that are older than the specified retentio time of if the space bouund is exceeded for a partition, Kafka is alllowed to delete old data to free storage space.&lt;/p&gt;

&lt;p&gt;By default, topics are configured with a retention time of 7 days, but it&amp;rsquo;s also possible to sotre data indefinitely.&lt;/p&gt;

&lt;h3 id=&#34;2-compacted-topics&#34;&gt;2. Compacted topics&lt;/h3&gt;

&lt;p&gt;For compacted topics, records do not expire based on time or space bounds.
Instead, Kafka treats later messages as update to older message with the same key and guarantees never to delete the latest message per key. Users can delete messages entirely by writing a so called tombstone message with null value for a specific key.&lt;/p&gt;

&lt;h2 id=&#34;partitions&#34;&gt;Partitions&lt;/h2&gt;

&lt;h3 id=&#34;partitions-定義&#34;&gt;Partitions 定義&lt;/h3&gt;

&lt;p&gt;Topics may have many partitions, so it can handle an arbitrary amount of data.&lt;/p&gt;

&lt;h3 id=&#34;partition-offset&#34;&gt;Partition offset&lt;/h3&gt;

&lt;p&gt;Each partitioned message has a unique sequence id called as offset.&lt;/p&gt;

&lt;h3 id=&#34;replicas-of-partition&#34;&gt;Replicas of partition&lt;/h3&gt;

&lt;p&gt;Replicas are nothing but backups of a partition. Replicas are never read or write data. They are used to prevent data loss.&lt;/p&gt;

&lt;h2 id=&#34;brokers&#34;&gt;Brokers&lt;/h2&gt;

&lt;h3 id=&#34;brokers-定義&#34;&gt;Brokers 定義&lt;/h3&gt;

&lt;p&gt;Brokers are simple system responsible for maintaining the pub-lished data. Each broker may have zero or more partitions per topic. Assume, if there are N partitions in a topic and N number of brokers, each broker will have one partition.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Assume if there are N partitions in a topic and more than N brokers (n + m), the first N broker will have one partition and the next M broker will not have any partition for that particular topic.&lt;/li&gt;
&lt;li&gt;Assume if there are N partitions in a topic and less than N brokers (n-m), each broker will have one or more partition sharing among them. This scenario is not recommended due to unequal load distri-bution among the broker.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;stateless&#34;&gt;Stateless&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;透過 Zookeeper 來維持 Cluster State，Kafka broker instance 每秒需要處理上千個 read/write，每個 broker 可以處理 TB 級別的訊息並不影響 performance。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kafka-cluster&#34;&gt;Kafka Cluster&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;資料流可被分為多個不同的 partition 以及 topics&lt;/li&gt;
&lt;li&gt;Within a partition 裡面，訊息根據 offset (位置) 嚴格排序，並和 timestamp 一同存放。&lt;/li&gt;
&lt;li&gt;Kafka’s having more than one broker are called as Kafka cluster. A Kafka cluster can be expanded without downtime. These clusters are used to manage the persistence and replication of message data.&lt;/li&gt;
&lt;li&gt;通常都會有多個 Broker 做 Load Balancing&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;consumers&#34;&gt;Consumers&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;從 partition 讀取訊息&lt;/li&gt;
&lt;li&gt;Consumers read data from brokers. Consumers subscribes to one or more topics and consume published messages by pulling data from the brokers.&lt;/li&gt;
&lt;li&gt;Since Kafka brokers are stateless, which means that the consumer has to maintain how many messages have been consumed by using partition offset. If the consumer acknowledges a particular message offset, it implies that the consumer has consumed all prior messages. The consumer issues an asynchronous pull request to the broker to have a buffer of bytes ready to consume. The consumers can rewind or skip to any point in a partition simply by supplying an offset value. Consumer offset value is notified by ZooKeeper.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;leader&#34;&gt;Leader&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Leader is the node responsible for all reads and writes for the given partition. Every partition has one server acting as a leader.&lt;/li&gt;
&lt;li&gt;Broker Leader election 可透過 Zookeeper 完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;follower&#34;&gt;Follower&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Node which follows leader instructions are called as follower. If the leader fails, one of the follower will automatically become the new leader. A follower acts as normal consumer, pulls messages and up-dates its own data store.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;zookeeper&#34;&gt;ZooKeeper&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;負責管理及協調 Kafka broker&lt;/li&gt;
&lt;li&gt;通知 Producer 及 consumer

&lt;ul&gt;
&lt;li&gt;新的 broker 出現&lt;/li&gt;
&lt;li&gt;broker failure&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;當 Zookeeper 發出通知，Consumer 及 Producer 根據通知決定要使用哪一個 broker&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cluster&#34;&gt;Cluster&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kafka 叢集可運行在一個或多個 Server&lt;/li&gt;
&lt;li&gt;Partitions of all topics are distributed across the cluster nodes.&lt;/li&gt;
&lt;li&gt;This architecture allows Kafka to deliver massice streams of message in a fault-tolerant fashion and has allowed it to replace some of the conventional messaging systems like Java Message Service, Advanced Message Queuing Protocol.&lt;/li&gt;
&lt;li&gt;Offers trancactional writes, which provide stream processing using the streams API.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/apache_kafka/apache_kafka_introduction.htm&#34;&gt;https://www.tutorialspoint.com/apache_kafka/apache_kafka_introduction.htm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
       </item>
       
     </channel>
   </rss>
