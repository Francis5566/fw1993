<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>datastructure | goatwu1993</title>
    <link>https://goatwu1993.github.io/blog/categories/datastructure/</link>
      <atom:link href="https://goatwu1993.github.io/blog/categories/datastructure/index.xml" rel="self" type="application/rss+xml" />
    <description>datastructure</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Thu, 26 Dec 2019 19:17:18 +0800</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>datastructure</title>
      <link>https://goatwu1993.github.io/blog/categories/datastructure/</link>
    </image>
    
    <item>
      <title>Python 實作 Dictionary</title>
      <link>https://goatwu1993.github.io/blog/posts/dict-python-implementation/</link>
      <pubDate>Thu, 26 Dec 2019 19:17:18 +0800</pubDate>
      <guid>https://goatwu1993.github.io/blog/posts/dict-python-implementation/</guid>
      <description>&lt;h2 id=&#34;dictionary&#34;&gt;Dictionary&lt;/h2&gt;
&lt;p&gt;Python Dictionary 的好用大家都知道，反過來，我覺得用 Python 實作一個 Dictionary 是個複習資料結構的好方法。&lt;/p&gt;
&lt;h2 id=&#34;瞄一下&#34;&gt;瞄一下&lt;/h2&gt;
&lt;p&gt;瞄一下
&lt;a href=&#34;https://github.com/python/cpython/blob/master/Objects/dictobject.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cpython&lt;/a&gt;
怎麼寫，
&lt;a href=&#34;https://www.data-structures-in-practice.com/hash-tables/?fbclid=IwAR351NVEsa5779Ph_8wG7Pi5U40bQlafRDuXAZxAtJO-WOpCCjEMqv7g5HY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;這邊&lt;/a&gt;
有詳細解釋。&lt;/p&gt;
&lt;h2 id=&#34;hash-table-優點&#34;&gt;Hash table 優點&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;O(1) insertion&lt;/li&gt;
&lt;li&gt;O(1) get&lt;/li&gt;
&lt;li&gt;O(1) delete&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是要在 laod factor 在一定範圍內才能給出時間複雜度 O(1)的但書。&lt;/p&gt;
&lt;h2 id=&#34;load-factor--dynamic-resizing&#34;&gt;Load Factor &amp;amp; dynamic resizing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_table#Resizing_by_copying_all_entries&#34;&gt;https://en.wikipedia.org/wiki/Hash_table#Resizing_by_copying_all_entries&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Load Factor = n/k&lt;/li&gt;
&lt;li&gt;n is the number of entries occupied in the hash table.&lt;/li&gt;
&lt;li&gt;k is the number of buckets.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;k 也叫做 table size， n 為資料筆數，k 通常略大於 n，留下(k-n)筆空白欄位。&lt;/p&gt;
&lt;p&gt;實務上控制 Load factor 介於 0.3 至 0.7 ，時間 O(1)的同時 k 還小。&lt;/p&gt;
&lt;h2 id=&#34;dictionary-node&#34;&gt;Dictionary Node&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class DictionaryNode():
    &amp;quot;&amp;quot;&amp;quot;
    Node of a DictionaryLinkedList.
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self, key, value, me_hash):
        self.key = key
        self.value = value
        self.me_hash = me_hash
        self.collided = False

    def __repr__(self):
        return (self.key.__repr__() + &amp;quot;: &amp;quot; + self.value.__repr__())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;me_hash&#34;&gt;me_hash&lt;/h3&gt;
&lt;p&gt;key 的 hash 值，cpython get 的時候比對會用到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;(ep-&amp;gt;me_key == key ||
(ep-&amp;gt;me_hash == hash &amp;amp;&amp;amp; unicode_eq(ep-&amp;gt;me_key, key)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;詳細原因可能要對編碼比較熟才看得懂，我存著 resize 就不需要重算一次。&lt;/p&gt;
&lt;h3 id=&#34;collided&#34;&gt;collided&lt;/h3&gt;
&lt;p&gt;判斷是否 collide 過的 flag，若 delete 時 collided 為 True，告訴大家這 node 沒有值但需要往後尋找，若沒有 collide 過則代表沒有 collide 過，返回 indexError。&lt;/p&gt;
&lt;h2 id=&#34;dictionary-class&#34;&gt;Dictionary Class&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Dictionary():
    &amp;quot;&amp;quot;&amp;quot;
    Dictionary are implemented by HashTable
    Using open addressing method.
    Hash using siphash. I can not find siphash
    &amp;quot;&amp;quot;&amp;quot;

    def __init__(self):
        self.used_entry = 0
        self.buckets = [None for x in range(0, 8)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始大小為 8 ，python 沒有辦法 override {} 的讀取， KVP 只能慢慢塞。&lt;/p&gt;
&lt;p&gt;另外存取 used_entry 以免 len()需要跑 O(n)的 loop，insert/del 要記得 maintain。&lt;/p&gt;
&lt;h2 id=&#34;hash&#34;&gt;Hash&lt;/h2&gt;
&lt;p&gt;仿照 cpython 用 siphash，據作者所述是一個快速的 hash ，用過 md5 也是可以的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install siphash
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from siphash import siphash24
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dictionary-的-me_hash&#34;&gt;Dictionary 的 me_hash()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def me_hash(self, key):
        &amp;quot;&amp;quot;&amp;quot;
        hash of key
        &amp;quot;&amp;quot;&amp;quot;
        return siphash24(b&#39;0123456789ABCDEF&#39;,(str(key).encode(&#39;utf-8&#39;))).hash()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dynamic-resizing&#34;&gt;Dynamic Resizing&lt;/h2&gt;
&lt;h3 id=&#34;bitmask--運算&#34;&gt;bitmask (&amp;amp;) 運算&lt;/h3&gt;
&lt;p&gt;當 k (table size) 是 2 的 m 次方，則 hash(n) mod k 可以用 hash(n) &amp;amp; bitmask 取代，其中 bitmask 為 m 個 1 組成。&lt;/p&gt;
&lt;h3 id=&#34;bitmask--in-python-terminal&#34;&gt;bitmask (&amp;amp;) in Python terminal&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def hash(key): return siphash24(b&#39;0123456789ABCDEF&#39;,(str(key).encode(&#39;utf-8&#39;))).hash()
...
&amp;gt;&amp;gt;&amp;gt; n = &#39;key_string&#39;
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; # m = 3, k = 8
...
&amp;gt;&amp;gt;&amp;gt; hash(n) &amp;amp; 0b111 == hash(n) &amp;amp; 7
True
&amp;gt;&amp;gt;&amp;gt; hash(n) &amp;amp; 0b111 == hash(n) % 8
True
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; # m = 4, k = 16
...
&amp;gt;&amp;gt;&amp;gt; hash(n) &amp;amp; 0b1111 == hash(n) &amp;amp; 15
True
&amp;gt;&amp;gt;&amp;gt; hash(n) &amp;amp; 0b1111 == hash(n) % 16
True
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;resizing-程式碼&#34;&gt;Resizing 程式碼&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def resize(self):
        &amp;quot;&amp;quot;&amp;quot;
        Should change the size if load_factor &amp;gt; 2/3 or load_factor &amp;lt; 2/3
        Should do nothing if load_factor between 1/3 and 2/3
        &amp;quot;&amp;quot;&amp;quot;
        def proper_size(n, k):
            pro_size = 8 if n &amp;lt;= 2 else 2**(int(n * 1.5)).bit_length()
            return pro_size

        used = self.used_entry
        old_size = len(self.buckets)
        new_size = proper_size(used, old_size)
        if old_size == new_size:
            return
        new_buckets = [None for x in range(0, new_size)]
        for i in range(old_size):
            if self.buckets[i] and (self.buckets[i].key is not None):
                key_me_hash = self.buckets[i].me_hash
                # &amp;amp; for bitwise operation (bitmask)
                entry = key_me_hash &amp;amp; (new_size-1)
                while new_buckets[entry]:
                    new_buckets[entry].collided = True
                    entry = entry+1 if entry &amp;lt; (new_size-2) else 0
                new_buckets[entry] = self.buckets[i]
                new_buckets[entry].collided = False
        self.buckets = new_buckets
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;magic-methods&#34;&gt;Magic Methods&lt;/h2&gt;
&lt;h3 id=&#34;實作-python-內建的-magic-methods&#34;&gt;實作 python 內建的 Magic Methods&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# __setitem__
a[b] = c
# __getitem__
a[b]
# __len__
len(a)
# __delitem__
del a[b]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;open-addressing&#34;&gt;Open Addressing&lt;/h3&gt;
&lt;p&gt;這裡用的是最簡單的 open addressing，entry 被佔據就找下一個，比較簡單，但容易有連續一整攤都被 occupied 的情形發生，如果有興趣可以實作其他的 open addressing 算法。&lt;/p&gt;
&lt;h3 id=&#34;magic-methods-程式碼&#34;&gt;Magic Methods 程式碼&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    def __repr__(self):
        s = &#39;&#39;
        for i in range(len(self.buckets)):
            if self.buckets[i]:
                s = s + self.buckets[i].__repr__() + &#39;, &#39;
        return {} if not s else &amp;quot;{{{0}}}&amp;quot;.format(s[:-3])

    def __getitem__(self, key):
        key_me_hash = self.me_hash(key)
        l = len(self.buckets)
        entry = key_me_hash &amp;amp; (l-1)
        while self.buckets[entry]:
            if self.buckets[entry].key == key:
                return self.buckets[entry].value
            if not self.buckets[entry].collided:
                raise KeyError(key)
            entry = entry+1 if entry &amp;lt; (l-2) else 0
        raise KeyError(key)

    def __setitem__(self, key, value):
        self.used_entry += 1
        self.resize()

        l = len(self.buckets)
        key_me_hash = self.me_hash(key)
        entry = key_me_hash &amp;amp; (l-1)
        while self.buckets[entry]:
            self.buckets[entry].collided = True
            entry = entry+1 if entry &amp;lt; (l-2) else 0
        self.buckets[entry] = DictionaryNode(key=key,
                                             value=value,
                                             me_hash=key_me_hash)

    def __delitem__(self, key):
        key_me_hash = self.me_hash(key)
        l = len(self.buckets)
        entry = key_me_hash &amp;amp; (l-1)
        while self.buckets[entry]:
            if self.buckets[entry].key == key:
                self.buckets[entry].key = None
                self.buckets[entry].value = None
                self.buckets[entry].me_hash = None
                return
            if not self.buckets[entry].collided:
                raise KeyError(key)
            entry = entry+1 if entry &amp;lt; (l-2) else 0
        raise KeyError(key)

    def __len__(self):
        counter = 0
        for i in range(len(self.buckets)):
            if self.buckets[i]:
                counter += 1
        return counter
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整程式碼&#34;&gt;完整程式碼&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/goatwu1993/data_structure/blob/master/hash_table.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;Python 自己內建的資料結構，很多都是直接用 c 寫的，速度上快很多，如果沒必要，還是直接用就好了&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.data-structures-in-practice.com/hash-tables/?fbclid=IwAR351NVEsa5779Ph_8wG7Pi5U40bQlafRDuXAZxAtJO-WOpCCjEMqv7g5HY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大神解說&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_table#Resizing_by_copying_all_entries&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/python/cpython/blob/master/Objects/dictobject.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cpython&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://blog.csdn.net/yuan_j_y/article/details/9317817&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Magic Method&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
