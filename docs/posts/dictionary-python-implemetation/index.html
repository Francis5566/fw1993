<!DOCTYPE html>
<html lang="en-us"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>怎麽用 Python 實作一個 Dictionary - goatwu1993</title>
    <base href="https://goatwu1993.github.io/blog/">
    <link rel="stylesheet" href="https://goatwu1993.github.io/blog/css/styles.css">
    <link rel="stylesheet" href="https://goatwu1993.github.io/blog/css/font.css">
</head>
<body><header>
    <nav class="breadcrumb grape">
	<h4><a href="/blog/">goatwu1993</a></h4>
	<div id="space"></div>
        
        <a href="/blog/tags/">Tags</a>
        
        <a href="/blog/post/">Posts</a>
        
        <a href="/blog/about/">About</a>
        
    </nav>
</header>

<main id="single">
    <div id="post" class="white">
	<div class="container">
	    <div id="title">
                <h1>怎麽用 Python 實作一個 Dictionary</h1>
                <time datetime="2019-12-26T19:17:18&#43;0800">2019-12-26</time>

	    </div>
            <section class="post-content">
                

<h2 id="dictionary">Dictionary</h2>

<p>Python Dictionary 的好大家都知道，這篇反過來用 Python 實作一個 Dictionary</p>

<h2 id="先開大招">先開大招</h2>

<p>直接偷看答案，看看 <a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c">cpython</a>怎麼寫準沒錯，用 C 寫看起來就很難 R<br />
還好<a href="https://www.data-structures-in-practice.com/hash-tables/?fbclid=IwAR351NVEsa5779Ph_8wG7Pi5U40bQlafRDuXAZxAtJO-WOpCCjEMqv7g5HY">這邊</a>有一篇解釋，總之，key-value pair 用 hash table 是正義，實作上的眉眉角角才是重點。</p>

<h2 id="hash-table-的好">Hash table 的好</h2>

<ul>
<li>O(1) insertion</li>
<li>O(1) get</li>
<li>O(1) delete</li>
</ul>

<p>O(1) 948784 狂，然而以上 O(1)的時間複雜度，都是指 average case 。</p>

<p>當 entry 越來越滿，worst case 就容易發生，worst case 發生的機率和下面要講的 load factor 正相關。</p>

<h2 id="load-factor-dynamic-resizing">load factor &amp; dynamic resizing</h2>

<p><a href="https://en.wikipedia.org/wiki/Hash_table#Resizing_by_copying_all_entries">wiki</a></p>

<p>load factor = n/k</p>

<ul>
<li>n is the number of entries occupied in the hash table.</li>
<li>k is the number of buckets.</li>
</ul>

<p>k 通常也被叫做 table size。有 n 筆資料，不會只開 n 個 entry，而是稍微大一些的 k 筆，所以 n 總共佔 k 的比例就是 load factor。</p>

<ul>
<li>當 load factor 趨近 1，Worst Case 機率增加，平均查找時間 O(n)</li>
<li>當 load factor 趨近 0，Worst Case 機率較少，平均查找時間 O(1)。</li>
</ul>

<p>實務上</p>

<ul>
<li>開 Dictionary 要預估資料的筆數 n 很不實際</li>
<li>load factor 趨近於 0，雖然有 O(1)的查找，但 k &gt;&gt; n 表示要開很大的 table size 儲存相對很少的資料，很浪費空間。</li>
<li>load factro 趨近於 1，很省空間，但查找時間趨近 O(n)，失去 hash table 的初心。</li>
</ul>

<p>因此一般來說 load factor 為 0.6~0.7 是空間換取時間比較平衡的地帶，根據 n 調整 k 的手段就是 dynamic resizing</p>

<h2 id="code">Code</h2>

<h3 id="dictionary-node">Dictionary Node</h3>

<pre><code class="language-python">class DictionaryNode():
    &quot;&quot;&quot;
    Node of a DictionaryLinkedList.
    &quot;&quot;&quot;

    def __init__(self, key, value, me_hash):
        self.key = key
        self.value = value
        self.me_hash = me_hash
        self.collided = False

    def __repr__(self):
        return (self.key.__repr__() + &quot;: &quot; + self.value.__repr__())
</code></pre>

<h4 id="me-hash">me_hash</h4>

<p>me_hash 是 key 的 hash 值，根據 cpython 以及講解，是 get 的時候比對會用到</p>

<pre><code class="language-c">(ep-&gt;me_key == key ||
(ep-&gt;me_hash == hash &amp;&amp; unicode_eq(ep-&gt;me_key, key)))
</code></pre>

<p>感覺是比對</p>

<ul>
<li>key 值本身</li>
<li>hash+unicode</li>
</ul>

<p>兩者其中一俄個 True 則認為 key 相同，詳細情形可能要對編碼比較熟才看得懂，這份 code 放著等以免 resize 要重算一次。</p>

<h4 id="collided">collided</h4>

<p>一個確認有沒有 collide 過的 flag</p>

<ul>
<li><p>insert<br />
若 entry 已被佔用，則將此 entry 的 collided 屬性設定為 True，再往後面找。</p></li>

<li><p>delete<br />
若 collide 為 True，應該將 key, value 設定為 None 或是整個 node 換成另一種 class，告訴大家這 node 已經被刪除了，但你還是應該往後尋找。</p></li>

<li><p>get 的 pseudo code</p>

<pre><code class="language-python">def get(key):
    entry = me_hash(key)
    while is_valid(entry):
        if hash_table[entry] == None:
            # 這個Entry從來沒有被使用過
            raise IndexError('key not exist')
        elif hash_table[entry] and \
                hash_table[entry].key != key and \
                not hash_table[entry].collided:
            # 此entry已經有值，但key不對，但沒有發生過collided=&gt;
            # 只是剛好entry相同，且沒發生collide，直接返回indexError即可
            raise IndexError('key not exist')
        elif hash_table[entry] and \
                hash_table[entry].key != key and \
                hash_table[entry].collided:
            # 此entry已經有值，但key不對，但有發生過collided =&gt;
            # 往下查找
            entry += 1
        elif hash_table[entry] and \
            not hash_table[entry].key and \
            not hash_table[entry].value and
        hash_table[entry].collided:
            # 此Node被del，但為了提示之後要往後查找，流下 collided 屬性。
            entry += 1
        elif hash_table[entry] and hash_table[entry].key == key:
            return hash_table[entry].value
</code></pre></li>
</ul>

<h3 id="dictionary-class">Dictionary Class</h3>

<pre><code class="language-python">class Dictionary():
    &quot;&quot;&quot;
    Dictionary are implemented by HashTable
    Using open addressing method.
    Hash using siphash. I can not find siphash
    &quot;&quot;&quot;

    def __init__(self):
        self.used_entry = 0
        self.buckets = [None for x in range(0, 8)]
</code></pre>

<p>先開一個大小為 8 的 list，由於沒有實作{}的讀取，因此 KVP 只能一個一個 set。</p>

<p>另外由於不想每次要拿長度或是算 load factor 的時候都要去做一個 O(k)的 for loop，因此直接開一個欄位(self.used_entry)來記，insert/del 要記得 maintain。</p>

<h3 id="hash">Hash</h3>

<p>這邊一樣仿照 cpython 用 siphash</p>

<pre><code class="language-bash">pip install siphash
</code></pre>

<pre><code class="language-python">from siphash import siphash24
...
...
...
    def me_hash(self, key):
        &quot;&quot;&quot;
        hash of key
        &quot;&quot;&quot;
        return siphash24(b'0123456789ABCDEF',(str(key).encode('utf-8'))).hash()
</code></pre>

<p>據說是一個相對平均且快速的 hash 方法，和加密用的 hash 要求似乎有點不太一樣(用過 md5 也是很 OK 的，只是轉成 int 相較麻煩，還要 digest 什麼的)，開頭要記得 import。</p>

<h3 id="resize-dynamic-resizing">Resize (dynamic resizing)</h3>

<h4 id="proper-size">proper_size</h4>

<p>給定 n 筆 data，根據 load factor 的合理範圍算出合適的 data_size，原則</p>

<ul>
<li><sup>1</sup>&frasl;<sub>3</sub> &lt; n/proper_size &lt; <sup>2</sup>&frasl;<sub>3</sub></li>
<li>proper_size 為 2 的任意正整數次方(2^integer)</li>
</ul>

<h4 id="resize">resize</h4>

<p>任何牽涉到 len 增加/減少時都應該呼叫，算出 proper_size，若 data_size 改變則把 buckets 裡面的東西全部 dump 到 new_buckets。</p>

<h4 id="bitmask-運算">bitmask (&amp;) 運算</h4>

<p>當 table size 是 2 的次方，會發現可以用 hash &amp; bitmask 得到 entry，python 可以用</p>

<pre><code class="language-python">&amp;
</code></pre>

<p>運算子得到類似 bitmask 的結果，簡單來說當 size 為 2 的任意正整數次方，則</p>

<pre><code class="language-python">hash &amp; (k-1) == hash % k
</code></pre>

<p>運算速度還比較快。</p>

<pre><code class="language-python">    def resize(self):
        &quot;&quot;&quot;
        Should change the size if load_factor &gt; 2/3 or load_factor &lt; 2/3
        Should do nothing if load_factor between 1/3 and 2/3
        &quot;&quot;&quot;
        def proper_size(n, k):
            pro_size = 8 if n &lt;= 2 else 2**(int(n * 1.5)).bit_length()
            return pro_size

        used = self.used_entry
        old_size = len(self.buckets)
        new_size = proper_size(used, old_size)
        if old_size == new_size:
            return
        new_buckets = [None for x in range(0, new_size)]
        for i in range(old_size):
            if self.buckets[i] and (self.buckets[i].key is not None):
                key_me_hash = self.buckets[i].me_hash
                # &amp; for bitwise operation (bitmask)
                entry = key_me_hash &amp; (new_size-1)
                while new_buckets[entry]:
                    new_buckets[entry].collided = True
                    entry = entry+1 if entry &lt; (new_size-2) else 0
                new_buckets[entry] = self.buckets[i]
                new_buckets[entry].collided = False
        self.buckets = new_buckets
</code></pre>

<h3 id="python-magic-methods">python Magic Methods</h3>

<p>為了讓這個 class 更像內建的 dictionary，需要實作幾個 python 內建的 Magic Methods</p>

<pre><code class="language-python"># __setitem__
a[b] = c
# __getitem__
a[b]
# __len__
len(a)
# __delitem__
del a[b]
</code></pre>

<p>基本上就是把 insert/del/search 用 Magic Method 實作，這裡用的是最簡單的 open addressing，entry 被佔據就找下一個，比較簡單，但容易有連續一整攤都被 occupied 的情形發生，如果有興趣可以實作其他的 open addressing 算法。</p>

<pre><code class="language-python">    def __repr__(self):
        s = ''
        for i in range(len(self.buckets)):
            if self.buckets[i]:
                s = s + self.buckets[i].__repr__() + ', '
        return {} if not s else &quot;{{{0}}}&quot;.format(s[:-3])

    def __getitem__(self, key):
        key_me_hash = self.me_hash(key)
        l = len(self.buckets)
        entry = key_me_hash &amp; (l-1)
        while self.buckets[entry]:
            if self.buckets[entry].key == key:
                return self.buckets[entry].value
            if not self.buckets[entry].collided:
                raise KeyError(key)
            entry = entry+1 if entry &lt; (l-2) else 0
        raise KeyError(key)

    def __setitem__(self, key, value):
        self.used_entry += 1
        self.resize()

        l = len(self.buckets)
        key_me_hash = self.me_hash(key)
        entry = key_me_hash &amp; (l-1)
        while self.buckets[entry]:
            self.buckets[entry].collided = True
            entry = entry+1 if entry &lt; (l-2) else 0
        self.buckets[entry] = DictionaryNode(key=key,
                                             value=value,
                                             me_hash=key_me_hash)

    def __delitem__(self, key):
        key_me_hash = self.me_hash(key)
        l = len(self.buckets)
        entry = key_me_hash &amp; (l-1)
        while self.buckets[entry]:
            if self.buckets[entry].key == key:
                self.buckets[entry].key = None
                self.buckets[entry].value = None
                self.buckets[entry].me_hash = None
                return
            if not self.buckets[entry].collided:
                raise KeyError(key)
            entry = entry+1 if entry &lt; (l-2) else 0
        raise KeyError(key)

    def __len__(self):
        counter = 0
        for i in range(len(self.buckets)):
            if self.buckets[i]:
                counter += 1
        return counter
</code></pre>

<h2 id="完整程式碼">完整程式碼</h2>

<p><a href="https://github.com/goatwu1993/data_structure/blob/master/hash_table.py">Github</a></p>

<h2 id="reference">Reference</h2>

<p>最後附上參考資料，建議看第一個，講的很清楚，有一些太難的地方我也沒有仔細看懂就寫完了&hellip;</p>

<ul>
<li><a href="https://www.data-structures-in-practice.com/hash-tables/?fbclid=IwAR351NVEsa5779Ph_8wG7Pi5U40bQlafRDuXAZxAtJO-WOpCCjEMqv7g5HY">大神解說</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hash_table#Resizing_by_copying_all_entries">wiki</a></li>
<li><a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c">cpython</a></li>
<li><a href="https://blog.csdn.net/yuan_j_y/article/details/9317817">Magic Method</a></li>
</ul>

            </section>
	</div>
    </div>
</main>
<footer class="sand">
    <span class="footer-text">Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a></span>
</footer>
<link rel="stylesheet" href="https://goatwu1993.github.io/blog/css/solarized-light.css"/>
<script src="https://goatwu1993.github.io/blog/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
