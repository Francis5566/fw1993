<!doctype html>
<html lang="en-us">
  <head>
    <title>Python 實作 Dictionary // goatwu1993</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://goatwu1993.github.io/blog/css/main.min.68e582a4d4ed824d6b7e3b5b37cae47eb3779bd631046379d0e68b38230cc3e2.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python 實作 Dictionary"/>
<meta name="twitter:description" content="A python implemented dictionary."/>

    <meta property="og:title" content="Python 實作 Dictionary" />
<meta property="og:description" content="A python implemented dictionary." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://goatwu1993.github.io/blog/posts/datastructure/dict-python-implementation/" />
<meta property="article:published_time" content="2019-12-26T19:17:18+08:00" />
<meta property="article:modified_time" content="2019-12-26T19:17:18+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://goatwu1993.github.io/blog/"><img class="app-header-avatar" src="" alt="John Doe" /></a>
      <h1>goatwu1993</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="#posts">Posts</a>
             - 
          
          <a class="app-header-menu-item" href="#about">About</a>
             - 
          
          <a class="app-header-menu-item" href="#tags">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="./posts">Categories</a>
      </nav>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Python 實作 Dictionary</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Dec 26, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://goatwu1993.github.io/blog/tags/python/">python</a>
              <a class="tag" href="https://goatwu1993.github.io/blog/tags/datastructure/">datastructure</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="dictionary">Dictionary</h2>
<p>Python Dictionary 的好用大家都知道，反過來，我覺得用 Python 實作一個 Dictionary 是個複習資料結構的好方法。</p>
<h2 id="瞄一下">瞄一下</h2>
<p>瞄一下<a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c">cpython</a>怎麼寫，<a href="https://www.data-structures-in-practice.com/hash-tables/?fbclid=IwAR351NVEsa5779Ph_8wG7Pi5U40bQlafRDuXAZxAtJO-WOpCCjEMqv7g5HY">這邊</a>有詳細解釋。</p>
<h2 id="hash-table-優點">Hash table 優點</h2>
<ul>
<li>O(1) insertion</li>
<li>O(1) get</li>
<li>O(1) delete</li>
</ul>
<p>但是要在 laod factor 在一定範圍內才能給出時間複雜度 O(1)的但書。</p>
<h2 id="load-factor--dynamic-resizing">Load Factor &amp; dynamic resizing</h2>
<p><a href="https://en.wikipedia.org/wiki/Hash_table#Resizing_by_copying_all_entries">https://en.wikipedia.org/wiki/Hash_table#Resizing_by_copying_all_entries</a></p>
<p>$$Load Factor = n/k $$</p>
<p>$$ k : bucket 數目，也叫 table size$$
$$ n : 資料筆數，k 通常略大於 n，留下(k-n)筆空白欄位。$$</p>
<p>實務上控制 Load factor 介於 0.3 至 0.7 ，時間 O(1)的同時 k 還小。</p>
<h2 id="dictionary-node">Dictionary Node</h2>
<pre><code class="language-python">class DictionaryNode():
    &quot;&quot;&quot;
    Node of a DictionaryLinkedList.
    &quot;&quot;&quot;

    def __init__(self, key, value, me_hash):
        self.key = key
        self.value = value
        self.me_hash = me_hash
        self.collided = False

    def __repr__(self):
        return (self.key.__repr__() + &quot;: &quot; + self.value.__repr__())
</code></pre>
<h3 id="me_hash">me_hash</h3>
<p>key 的 hash 值，cpython get 的時候比對會用到</p>
<pre><code class="language-c">(ep-&gt;me_key == key ||
(ep-&gt;me_hash == hash &amp;&amp; unicode_eq(ep-&gt;me_key, key)))
</code></pre>
<p>詳細原因可能要對編碼比較熟才看得懂，我存著 resize 就不需要重算一次。</p>
<h3 id="collided">collided</h3>
<p>判斷是否 collide 過的 flag，若 delete 時 collided 為 True，告訴大家這 node 沒有值但需要往後尋找，若沒有 collide 過則代表沒有 collide 過，返回 indexError。</p>
<h2 id="dictionary-class">Dictionary Class</h2>
<pre><code class="language-python">class Dictionary():
    &quot;&quot;&quot;
    Dictionary are implemented by HashTable
    Using open addressing method.
    Hash using siphash. I can not find siphash
    &quot;&quot;&quot;

    def __init__(self):
        self.used_entry = 0
        self.buckets = [None for x in range(0, 8)]
</code></pre>
<p>初始大小為 8 ，python 沒有辦法 override {} 的讀取， KVP 只能慢慢塞。</p>
<p>另外存取 used_entry 以免 len()需要跑 O(n)的 loop，insert/del 要記得 maintain。</p>
<h2 id="hash">Hash</h2>
<p>仿照 cpython 用 siphash，據作者所述是一個快速的 hash ，用過 md5 也是可以的。</p>
<pre><code class="language-bash">pip install siphash
</code></pre>
<pre><code class="language-python">from siphash import siphash24
</code></pre>
<h3 id="dictionary-的-me_hash">Dictionary 的 me_hash()</h3>
<pre><code class="language-python">    def me_hash(self, key):
        &quot;&quot;&quot;
        hash of key
        &quot;&quot;&quot;
        return siphash24(b'0123456789ABCDEF',(str(key).encode('utf-8'))).hash()
</code></pre>
<h2 id="dynamic-resizing">Dynamic Resizing</h2>
<h3 id="bitmask--運算">bitmask (&amp;) 運算</h3>
<p>當 k (table size) 是 2 的 m 次方，則 hash(n) mod k 可以用 hash(n) &amp; bitmask 取代，其中 bitmask 為 m 個 1 組成。</p>
<h3 id="bitmask--in-python-terminal">bitmask (&amp;) in Python terminal</h3>
<pre><code class="language-python">&gt;&gt;&gt; def hash(key): return siphash24(b'0123456789ABCDEF',(str(key).encode('utf-8'))).hash()
...
&gt;&gt;&gt; n = 'key_string'
&gt;&gt;&gt;
&gt;&gt;&gt; # m = 3, k = 8
...
&gt;&gt;&gt; hash(n) &amp; 0b111 == hash(n) &amp; 7
True
&gt;&gt;&gt; hash(n) &amp; 0b111 == hash(n) % 8
True
&gt;&gt;&gt;
&gt;&gt;&gt; # m = 4, k = 16
...
&gt;&gt;&gt; hash(n) &amp; 0b1111 == hash(n) &amp; 15
True
&gt;&gt;&gt; hash(n) &amp; 0b1111 == hash(n) % 16
True
&gt;&gt;&gt;
</code></pre>
<h3 id="resizing-程式碼">Resizing 程式碼</h3>
<pre><code class="language-python">    def resize(self):
        &quot;&quot;&quot;
        Should change the size if load_factor &gt; 2/3 or load_factor &lt; 2/3
        Should do nothing if load_factor between 1/3 and 2/3
        &quot;&quot;&quot;
        def proper_size(n, k):
            pro_size = 8 if n &lt;= 2 else 2**(int(n * 1.5)).bit_length()
            return pro_size

        used = self.used_entry
        old_size = len(self.buckets)
        new_size = proper_size(used, old_size)
        if old_size == new_size:
            return
        new_buckets = [None for x in range(0, new_size)]
        for i in range(old_size):
            if self.buckets[i] and (self.buckets[i].key is not None):
                key_me_hash = self.buckets[i].me_hash
                # &amp; for bitwise operation (bitmask)
                entry = key_me_hash &amp; (new_size-1)
                while new_buckets[entry]:
                    new_buckets[entry].collided = True
                    entry = entry+1 if entry &lt; (new_size-2) else 0
                new_buckets[entry] = self.buckets[i]
                new_buckets[entry].collided = False
        self.buckets = new_buckets
</code></pre>
<h2 id="magic-methods">Magic Methods</h2>
<h3 id="實作-python-內建的-magic-methods">實作 python 內建的 Magic Methods</h3>
<pre><code class="language-python"># __setitem__
a[b] = c
# __getitem__
a[b]
# __len__
len(a)
# __delitem__
del a[b]
</code></pre>
<h3 id="open-addressing">Open Addressing</h3>
<p>這裡用的是最簡單的 open addressing，entry 被佔據就找下一個，比較簡單，但容易有連續一整攤都被 occupied 的情形發生，如果有興趣可以實作其他的 open addressing 算法。</p>
<h3 id="magic-methods-程式碼">Magic Methods 程式碼</h3>
<pre><code class="language-python">    def __repr__(self):
        s = ''
        for i in range(len(self.buckets)):
            if self.buckets[i]:
                s = s + self.buckets[i].__repr__() + ', '
        return {} if not s else &quot;{{{0}}}&quot;.format(s[:-3])

    def __getitem__(self, key):
        key_me_hash = self.me_hash(key)
        l = len(self.buckets)
        entry = key_me_hash &amp; (l-1)
        while self.buckets[entry]:
            if self.buckets[entry].key == key:
                return self.buckets[entry].value
            if not self.buckets[entry].collided:
                raise KeyError(key)
            entry = entry+1 if entry &lt; (l-2) else 0
        raise KeyError(key)

    def __setitem__(self, key, value):
        self.used_entry += 1
        self.resize()

        l = len(self.buckets)
        key_me_hash = self.me_hash(key)
        entry = key_me_hash &amp; (l-1)
        while self.buckets[entry]:
            self.buckets[entry].collided = True
            entry = entry+1 if entry &lt; (l-2) else 0
        self.buckets[entry] = DictionaryNode(key=key,
                                             value=value,
                                             me_hash=key_me_hash)

    def __delitem__(self, key):
        key_me_hash = self.me_hash(key)
        l = len(self.buckets)
        entry = key_me_hash &amp; (l-1)
        while self.buckets[entry]:
            if self.buckets[entry].key == key:
                self.buckets[entry].key = None
                self.buckets[entry].value = None
                self.buckets[entry].me_hash = None
                return
            if not self.buckets[entry].collided:
                raise KeyError(key)
            entry = entry+1 if entry &lt; (l-2) else 0
        raise KeyError(key)

    def __len__(self):
        counter = 0
        for i in range(len(self.buckets)):
            if self.buckets[i]:
                counter += 1
        return counter
</code></pre>
<h2 id="完整程式碼">完整程式碼</h2>
<p><a href="https://github.com/goatwu1993/data_structure/blob/master/hash_table.py">Github</a></p>
<h2 id="結論">結論</h2>
<p>Python 自己內建的資料結構，很多都是直接用 c 寫的，速度上快很多，如果沒必要，還是直接用就好了&hellip;</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.data-structures-in-practice.com/hash-tables/?fbclid=IwAR351NVEsa5779Ph_8wG7Pi5U40bQlafRDuXAZxAtJO-WOpCCjEMqv7g5HY">大神解說</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hash_table#Resizing_by_copying_all_entries">wiki</a></li>
<li><a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c">cpython</a></li>
<li><a href="https://blog.csdn.net/yuan_j_y/article/details/9317817">Magic Method</a></li>
</ul>
<p>$$
$$</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
